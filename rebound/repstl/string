/*
 * This file is part of the C++ translation of REBOUND.
 *
 * Original REBOUND (C) code by Hanno Rein and others.
 * This translation is licensed under the GNU General Public License v3 or later.
 *
 * REBOUND is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * REBOUND is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program.
 * If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once
#include <stddef.h>
#include <cstring>
#include <cmath>
#include "exception"

namespace rebound::repstl {
  class String {
  private:
    char* data = nullptr;
    size_t length = 0;
    size_t cap = 0; // not including null terminator
    static constexpr double GROW_FACTOR = 2;

    size_t ceil(double x) {
      size_t int_part = (size_t)x;
      return (x == int_part) ? int_part : int_part + 1;
    }

    void grow(size_t cap_, bool allow_shrink = false) {
      if (cap_ == cap) return;
      if (cap_ > cap || allow_shrink) {
        size_t new_len = length > cap_ ? cap_ : length;
        char* new_data = new char[cap_ + 1];
        std::memcpy(new_data, data, new_len);
        new_data[new_len] = '\0';
        delete[] data;
        data = new_data;
        length = new_len;
        cap = cap_;
      }
    }
  public:
    String() : data(nullptr), length(0), cap(0) {}
    String(const char* str) {
      if (str) {
        length = std::strlen(str);
        cap = length;
        data = new char[cap + 1];
        std::strcpy(data, str);
      } else {
        data = nullptr;
        length = 0;
        cap = 0;
      }
    }
    String(const String& other) {
      length = other.length;
      cap = other.cap;
      data = new char[cap + 1];
      if (other.data) std::strcpy(data, other.data);
      else data[0] = '\0';
    }
    String(String&& other) noexcept : data(other.data), length(other.length), cap(other.cap) {
      other.data = nullptr;
      other.length = 0;
      other.cap = 0;
    }

    String& operator=(const String& other) {
      if (this != &other) {
        length = other.length;
        cap = other.cap;
        char* new_data = new char[cap + 1];
        delete[] data;
        data = new_data;
        if (other.data) std::strcpy(data, other.data);
        else data[0] = '\0';
      }
      return *this;
    }

    String& operator=(String&& other) noexcept {
      if (this != &other) {
        delete[] data;
        data = other.data;
        cap = other.cap;
        length = other.length;
        other.data = nullptr;
        other.length = 0;
        other.cap = 0;
      }
      return *this;
    }

    ~String() { delete[] data; }

    const char* c_str() const { return data ? data : ""; }

    const char& operator[](size_t index) const { return data[index]; }
    char& operator[](size_t index) { return data[index]; }

    void clear() {
      length = 0;
    }

    void push_back(char c) {
      if (length == cap) grow(ceil(cap * GROW_FACTOR));
      data[length] = c;
      data[length + 1] = '\0';
      ++length;
    }

    void pop_back() {
      if (length == 0) return;
      --length;
      data[length] = '\0';
    }

    void del_char_at(size_t index) {
      if (index >= length) return;
      std::memmove(data + index, data + index + 1, length - index);
      --length;
    }

    size_t len() const { return length; }

    void del_char(char c) {
      if (!data) return;
      size_t new_length = 0;
      for (size_t i = 0; i < length; ++i) {
        if (data[i] != c) {
          data[new_length++] = data[i];
        }
      }
      data[new_length] = '\0';
      length = new_length;
    }

    const char& at(size_t index) const {
      if (index >= length) throw IndexOutOfBounds("Index out of range");
      return data[index];
    }

    char& at(size_t index) {
      if (index >= length) throw IndexOutOfBounds("Index out of range");
      return data[index];
    }

    bool operator==(const String& other) const {
      if (length != other.length) return false;
      return std::strcmp(c_str(), other.c_str()) == 0;
    }

    bool operator!=(const String& other) const { return !(*this == other); }
    bool operator<(const String& other) const { return std::strcmp(c_str(), other.c_str()) < 0; }
    bool operator>(const String& other) const { return std::strcmp(c_str(), other.c_str()) > 0; }
    bool operator<=(const String& other) const { return !(*this > other); }
    bool operator>=(const String& other) const { return !(*this < other); }

    bool is_empty() const { return length == 0; }

    char* begin() { return data; }
    char* end() { return data + length; }
    const char* cbegin() const { return data; }
    const char* cend() const { return data + length; }

    String operator+(const String& other) const {
      if (other.data == nullptr) return *this;
      String result(*this);
      for (size_t i = 0; i < other.length; ++i) result.push_back(other[i]);
      return result;
    }


    String operator+(const char* str) const {
      if (!str) return *this;
      String result(*this);
      size_t len = std::strlen(str);
      for (size_t i = 0; i < len; ++i) result.push_back(str[i]);
      return result;
    }

    String& operator+=(const String& other) {
      if (other.data == nullptr) return *this;
      for (size_t i = 0; i < other.length; ++i) push_back(other[i]);
      return *this;
    }

    String& operator+=(const char* str) {
      if (!str) return *this;
      size_t len = std::strlen(str);
      for (size_t i = 0; i < len; ++i) push_back(str[i]);
      return *this;
    }
  };

  inline unsigned long long int_pow(unsigned long long base, unsigned long long exp) {
    unsigned long long res = 1;
    for (unsigned long long i = 0; i < exp; ++i) res *= base;
    return res;
  }

  inline String operator+(const char* lhs, const String& rhs) { return String(lhs) + rhs; }

#pragma region string to int
  inline String stoull(unsigned long long val) {
    if (val == 0) return "0";
    String res;

    unsigned long long exp = 0;
    while (val >= int_pow(10, exp)) ++exp;
    while (exp > 0) {
      --exp;
      unsigned long long pow_of_10 = int_pow(10, exp);
      int digit = val / pow_of_10;
      val -= pow_of_10 * digit;
      res.push_back('0' + digit);
    }

    return res;
  }

  inline String stoll(long long val) {
    if (val == 0) return "0";
    if (val < 0) return "-" + stoll(-val);

    String res;

    unsigned long long exp = 0;
    while (val >= int_pow(10, exp)) ++exp;
    while (exp > 0) {
      --exp;
      unsigned long long pow_of_10 = int_pow(10, exp);
      int digit = val / pow_of_10;
      val -= pow_of_10 * digit;
      res.push_back('0' + digit);
    }

    return res;
  }

  inline String stoul(unsigned long val) {
    if (val == 0) return "0";
    String res;

    unsigned long long exp = 0;
    while (val >= int_pow(10, exp)) ++exp;
    while (exp > 0) {
      --exp;
      unsigned long long pow_of_10 = int_pow(10, exp);
      int digit = val / pow_of_10;
      val -= pow_of_10 * digit;
      res.push_back('0' + digit);
    }

    return res;
  }

  inline String stol(long val) {
    if (val == 0) return "0";
    if (val < 0) return "-" + stol(-val);

    String res;

    unsigned long long exp = 0;
    while (val >= int_pow(10, exp)) ++exp;
    while (exp > 0) {
      --exp;
      unsigned long long pow_of_10 = int_pow(10, exp);
      int digit = val / pow_of_10;
      val -= pow_of_10 * digit;
      res.push_back('0' + digit);
    }

    return res;
  }

  inline String stoui(unsigned int val) {
    if (val == 0) return "0";
    String res;

    unsigned long long exp = 0;
    while (val >= int_pow(10, exp)) ++exp;
    while (exp > 0) {
      --exp;
      unsigned long long pow_of_10 = int_pow(10, exp);
      int digit = val / pow_of_10;
      val -= pow_of_10 * digit;
      res.push_back('0' + digit);
    }

    return res;
  }

  inline String stoi(int val) {
    if (val == 0) return "0";
    if (val < 0) return "-" + stol(-val);

    String res;

    unsigned long long exp = 0;
    while (val >= int_pow(10, exp)) ++exp;
    while (exp > 0) {
      --exp;
      unsigned long long pow_of_10 = int_pow(10, exp);
      int digit = val / pow_of_10;
      val -= pow_of_10 * digit;
      res.push_back('0' + digit);
    }

    return res;
  }

  inline String stous(unsigned short val) {
    if (val == 0) return "0";
    String res;

    unsigned long long exp = 0;
    while (val >= int_pow(10, exp)) ++exp;
    while (exp > 0) {
      --exp;
      unsigned long long pow_of_10 = int_pow(10, exp);
      int digit = val / pow_of_10;
      val -= pow_of_10 * digit;
      res.push_back('0' + digit);
    }

    return res;
  }

  inline String stos(short val) {
    if (val == 0) return "0";
    if (val < 0) return "-" + stol(-val);

    String res;

    unsigned long long exp = 0;
    while (val >= int_pow(10, exp)) ++exp;
    while (exp > 0) {
      --exp;
      unsigned long long pow_of_10 = int_pow(10, exp);
      int digit = val / pow_of_10;
      val -= pow_of_10 * digit;
      res.push_back('0' + digit);
    }

    return res;
  }
#pragma endregion
}