/*
 * This file is part of the C++ translation of REBOUND.
 *
 * Original REBOUND (C) code by Hanno Rein and others.
 * This translation is licensed under the GNU General Public License v3 or later.
 *
 * REBOUND is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * REBOUND is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program.
 * If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once
#include <stddef.h>
#include <cstring>

namespace rebound::repstl {
  class String {
  private:
    char* data = nullptr;
    size_t length = 0;
    size_t cap = 0; // not including null terminator
    static constexpr int GROW_FACTOR = 2;

    inline size_t ceil(double x) {
      size_t int_part = (size_t)x;
      return (x == int_part) ? int_part : int_part + 1;
    }

    void grow(size_t cap_, bool allow_shrink = false);
    void ensure_capacity(size_t min_cap);
  public:
    String() : data(nullptr), length(0), cap(0) {}
    String(const char* str);
    String(const String& other);
    String(String&& other) noexcept : data(other.data), length(other.length), cap(other.cap) {
      other.data = nullptr;
      other.length = 0;
      other.cap = 0;
    }

    String& operator=(const String& other);
    String& operator=(String&& other) noexcept;
    ~String() { delete[] data; }
    const char* c_str() const { return data ? data : ""; }
    const char& operator[](size_t index) const { return data[index]; }
    char& operator[](size_t index) { return data[index]; }
    void clear() {
      length = 0;
      if (data) data[0] = '\0';
    }

    void push_back(char c);
    void pop_back();
    void del_char_at(size_t index);
    size_t len() const { return length; }
    void del_char(char c);

    const char& at(size_t index) const;
    char& at(size_t index);

    bool operator==(const String& other) const {
      if (length != other.length) return false;
      return std::strcmp(c_str(), other.c_str()) == 0;
    }

    bool operator!=(const String& other) const { return !(*this == other); }
    bool operator<(const String& other) const { return std::strcmp(c_str(), other.c_str()) < 0; }
    bool operator>(const String& other) const { return std::strcmp(c_str(), other.c_str()) > 0; }
    bool operator<=(const String& other) const { return !(*this > other); }
    bool operator>=(const String& other) const { return !(*this < other); }

    bool is_empty() const { return length == 0; }

    char* begin() { return data ? data : const_cast<char*>(""); }
    char* end() { return begin() + length + 1; }
    const char* cbegin() const { return data ? data : ""; }
    const char* cend() const { return cbegin() + length + 1; }

    String operator+(const String& other) const;
    String operator+(const char* str) const;
    String& operator+=(const String& other);
    String& operator+=(const char* str);
  };

  inline String operator+(const char* lhs, const String& rhs) { return String(lhs) + rhs; }

  String stoull(unsigned long long val);

  inline String stoll(long long val) {
    if (val == 0) return "0";
    else if (val < 0) return "-" + stoull(-val);
    else return stoull(val);
  }

  inline String stoul(unsigned long val) { return stoull(val); }
  inline String stol(long val) { return stoll(val); }
  inline String stoui(unsigned int val) { return stoull(val); }
  inline String stoi(int val) { return stoll(val); }
  inline String stous(unsigned short val) { return stoull(val); }
  inline String stos(short val) { return stoll(val); }
}